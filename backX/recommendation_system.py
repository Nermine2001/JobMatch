# -*- coding: utf-8 -*-
"""recommendation_system.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1J91-qoS3xPu_LOhUmMZ9N9AYLRg2zds0
"""

import pandas as pd
import numpy as np
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity
import re
from datetime import datetime
import json
from typing import List, Dict, Any, Optional
import logging

jobs = pd.read_csv('clean_jobs.csv')

jobs.columns

jobs = jobs[['title', 'company', 'location', 'date_posted', 'work_type', 'employment_type', 'description']]

jobs

"""# Phase 1 : Préprocessing des Données"""

class DataPreprocessor:
    def __init__(self):
        self.skill_normalizer = {
            "js": "javascript",
            "py": "python",
            "react native": "react",
            "html5": "html",
            "css3": "css",
            "nodejs": "node.js",
            "reactjs": "react",
            "vuejs": "vue",
            "angularjs": "angular",
            "c++": "cpp",
            "c#": "csharp",
            "ai": "artificial intelligence",
            "ml": "machine learning",
            "db": "database",
            "api": "rest api"
        }

    def clean_skills(self, skills_list: List[str]) -> List[str]:
        """Normalise et nettoie la liste des compétences"""

        if not skills_list:
            return []

        cleaned = []
        for skill in skills_list:

            if not skill:
                continue

            # Nettoyage basique
            skill = str(skill).lower().strip()
            skill = re.sub(r'[^\w\s]', '', skill)
            skill = re.sub(r'\s+', ' ', skill)

            # Normalisation
            skill = self.skill_normalizer.get(skill, skill)

            if len(skill) > 1:  # Éviter les compétences trop courtes
                cleaned.append(skill)

        return list(set(cleaned))  # Supprime les doublons

    def normalize_experience(self, years):
        """Normalise l'expérience sur une échelle 0-1"""
        if pd.isna(years) or years <= 0:
            return 0.0
        elif years >= 15:
            return 1.0
        else:
            return min(years / 15.0, 1.0)

    def normalize_salary(self, salary, min_market=25000, max_market=150000):
        """Normalise le salaire sur une échelle 0-1"""
        if pd.isna(salary) or salary <= min_market:
            return 0.0
        elif salary <= min_market:
            return 0.0
        elif salary >= max_market:
            return 1.0
        else:
            return (salary - min_market) / (max_market - min_market)

    def extract_text_features(self, job_description: str) -> str:
        """Extrait les features textuelles d'une description"""

        if not job_description:
            return ""

        # Supprime HTML, caractères spéciaux
        text = re.sub(r'<[^>]+>', '', str(job_description))
        text = re.sub(r'[^\w\s]', ' ', text)
        text = re.sub(r'\s+', ' ', text)
        text = text.lower().strip()

        return text

jobs

"""# Phase 2 : Vectorisation des Compétences"""

class SkillsVectorizer:
    def __init__(self):
        self.tfidf_vectorizer = TfidfVectorizer(
            max_features=500,
            stop_words='english',
            ngram_range=(1, 2),
            min_df=1,
            max_df=0.9
        )
        self.is_fitted = False

    def fit(self, all_skills_lists: List[List[str]]):
        """Entraîne le vectoriseur sur toutes les compétences"""
        try:
            # Créer le corpus
            corpus = []
            for skills_list in all_skills_lists:
                if skills_list:
                    corpus.append(' '.join(skills_list))

            if not corpus:
                corpus = ['']  # Corpus vide par défaut

            self.tfidf_vectorizer.fit(corpus)
            self.is_fitted = True
            logger.info(f"Vectoriseur entraîné avec {len(corpus)} documents")

        except Exception as e:
            logger.error(f"Erreur lors de l'entraînement du vectoriseur: {e}")
            # Vectoriseur de fallback
            self.tfidf_vectorizer = TfidfVectorizer(max_features=100, min_df=1)
            self.tfidf_vectorizer.fit([''])
            self.is_fitted = True

    def vectorize_skills(self, skills_list: List[str]) -> np.ndarray:
        """Convertit une liste de compétences en vecteur TF-IDF"""
        if not self.is_fitted:
            logger.warning("Vectoriseur non entraîné, utilisation d'un vecteur vide")
            return np.zeros(100)

        if not skills_list:
            return np.zeros(self.tfidf_vectorizer.max_features or 100)

        skills_text = ' '.join(skills_list)
        try:
            vector = self.tfidf_vectorizer.transform([skills_text])
            return vector.toarray()[0]
        except Exception as e:
            logger.error(f"Erreur lors de la vectorisation: {e}")
            return np.zeros(self.tfidf_vectorizer.max_features or 100)

    def calculate_skills_similarity(self, user_skills: List[str], job_skills: List[str]) -> float:
        """Calcule la similarité entre compétences utilisateur et job"""
        if not self.is_fitted:
            return 0.0

        user_vector = self.vectorize_skills(user_skills)
        job_vector = self.vectorize_skills(job_skills)

        # Éviter la division par zéro
        if np.linalg.norm(user_vector) == 0 or np.linalg.norm(job_vector) == 0:
            return 0.0

        similarity = cosine_similarity([user_vector], [job_vector])[0][0]
        return float(similarity)

"""# Phase 3 : Système de Scoring Multi-Critères"""

class JobRecommendationEngine:
    def __init__(self):
        self.preprocessor = DataPreprocessor()
        self.skills_vectorizer = SkillsVectorizer()

        # Poids des différents critères
        self.weights = {
            'skills_match': 0.40,
            'experience_match': 0.25,
            'location_match': 0.20,
            'salary_match': 0.10,
            'freshness_factor': 0.05
        }

    def initialize_vectorizer(self, user_profiles: List[Dict], job_offers: List[Dict]):
        """Initialise le vectoriseur avec toutes les compétences disponibles"""
        all_skills = []

        # Compétences des utilisateurs
        for user in user_profiles:
            user_skills = []
            if 'skills' in user:
                if isinstance(user['skills'], list):
                    user_skills = user['skills']
                elif isinstance(user['skills'], dict):
                    user_skills = user['skills'].get('technical', []) + user['skills'].get('soft', [])
            all_skills.append(self.preprocessor.clean_skills(user_skills))

        # Compétences des jobs
        for job in job_offers:
            job_skills = []
            if 'skills_required' in job:
                job_skills.extend(job['skills_required'] if isinstance(job['skills_required'], list) else [])
            if 'description' in job:
                # Extraire les compétences de la description
                desc_skills = self.extract_skills_from_description(job['description'])
                job_skills.extend(desc_skills)
            all_skills.append(self.preprocessor.clean_skills(job_skills))

        self.skills_vectorizer.fit(all_skills)

    def extract_skills_from_description(self, description: str) -> List[str]:
        """Extrait les compétences d'une description de job"""
        if not description:
            return []

        # Compétences techniques communes
        common_skills = [
            'python', 'javascript', 'java', 'react', 'node.js', 'angular', 'vue',
            'html', 'css', 'sql', 'mongodb', 'postgresql', 'aws', 'docker',
            'kubernetes', 'git', 'agile', 'scrum', 'machine learning', 'ai'
        ]

        description_lower = description.lower()
        found_skills = []

        for skill in common_skills:
            if skill in description_lower:
                found_skills.append(skill)

        return found_skills

    def calculate_skills_score(self, user_profile: Dict, job_offer: Dict) -> float:
        """Score basé sur la correspondance des compétences"""
        try:
            # Récupération des compétences utilisateur
            user_skills = []
            if 'skills' in user_profile:
                if isinstance(user_profile['skills'], list):
                    user_skills = user_profile['skills']
                elif isinstance(user_profile['skills'], dict):
                    user_skills = (user_profile['skills'].get('technical', []) +
                                 user_profile['skills'].get('soft', []))

            user_skills = self.preprocessor.clean_skills(user_skills)

            # Récupération des compétences du job
            job_skills = []
            if 'skills_required' in job_offer:
                job_skills.extend(job_offer['skills_required'] if isinstance(job_offer['skills_required'], list) else [])
            if 'description' in job_offer:
                desc_skills = self.extract_skills_from_description(job_offer['description'])
                job_skills.extend(desc_skills)

            job_skills = self.preprocessor.clean_skills(job_skills)

            if not user_skills or not job_skills:
                return 0.0

            # Similarité TF-IDF
            similarity = self.skills_vectorizer.calculate_skills_similarity(user_skills, job_skills)

            # Bonus pour les compétences exactes
            exact_matches = len(set(user_skills) & set(job_skills))
            total_required = len(job_skills)
            exact_match_ratio = exact_matches / max(total_required, 1)

            # Score final compétences
            final_score = (similarity * 0.6) + (exact_match_ratio * 0.4)
            return min(final_score, 1.0)

        except Exception as e:
            logger.error(f"Erreur calcul skills score: {e}")
            return 0.0

    def calculate_experience_score(self, user_profile: Dict, job_offer: Dict) -> float:
        """Score basé sur l'expérience"""
        try:
            user_exp = user_profile.get('experience', 0)
            if isinstance(user_exp, dict):
                user_exp = user_exp.get('years', 0)

            min_required = job_offer.get('experience_required', 0)
            if isinstance(min_required, str):
                # Extraire le nombre d'années de la chaîne
                numbers = re.findall(r'\d+', min_required)
                min_required = int(numbers[0]) if numbers else 0

            user_exp = float(user_exp) if user_exp else 0
            min_required = float(min_required) if min_required else 0

            if min_required == 0:
                return 1.0

            if user_exp < min_required:
                # Pénalité progressive si pas assez d'expérience
                return max(0.2, user_exp / min_required)
            elif user_exp > min_required * 2:
                # Légère pénalité si surqualifié
                return max(0.7, 1.0 - (user_exp - min_required * 2) * 0.05)
            else:
                # Dans la fourchette acceptable
                return 1.0

        except Exception as e:
            logger.error(f"Erreur calcul experience score: {e}")
            return 0.5

    def calculate_location_score(self, user_profile: Dict, job_offer: Dict) -> float:
        """Score basé sur la localisation"""
        try:
            user_location = user_profile.get('location', '').lower()
            job_location = job_offer.get('location', '').lower()

            # Vérifier si c'est du télétravail
            job_remote = job_offer.get('remote', False) or job_offer.get('work_type', '').lower() == 'remote'
            user_accepts_remote = user_profile.get('accepts_remote', True)

            # Perfect match si remote accepté
            if job_remote and user_accepts_remote:
                return 1.0

            # Match exact de localisation
            if user_location and job_location:
                # Comparaison simple de chaînes
                if user_location == job_location:
                    return 1.0
                # Vérifier si même ville/région
                elif user_location in job_location or job_location in user_location:
                    return 0.8

            # Si pas de match mais remote possible
            if job_remote:
                return 0.6

            # Aucun match
            return 0.2

        except Exception as e:
            logger.error(f"Erreur calcul location score: {e}")
            return 0.5

    def calculate_salary_score(self, user_profile: Dict, job_offer: Dict) -> float:
        """Score basé sur la correspondance salariale"""
        try:
            user_salary_expectation = user_profile.get('salary_expectation', 0)
            job_salary = job_offer.get('salary', 0)

            # Convertir en nombres si nécessaire
            if isinstance(user_salary_expectation, str):
                numbers = re.findall(r'\d+', user_salary_expectation)
                user_salary_expectation = int(numbers[0]) if numbers else 0

            if isinstance(job_salary, str):
                numbers = re.findall(r'\d+', job_salary)
                job_salary = int(numbers[0]) if numbers else 0

            user_salary_expectation = float(user_salary_expectation) if user_salary_expectation else 0
            job_salary = float(job_salary) if job_salary else 0

            # Si pas d'info salaire, score neutre
            if user_salary_expectation == 0 or job_salary == 0:
                return 0.5

            # Calcul de la différence en pourcentage
            diff_ratio = abs(job_salary - user_salary_expectation) / user_salary_expectation

            if diff_ratio <= 0.1:  # Différence <= 10%
                return 1.0
            elif diff_ratio <= 0.2:  # Différence <= 20%
                return 0.8
            elif diff_ratio <= 0.3:  # Différence <= 30%
                return 0.6
            else:
                return 0.3

        except Exception as e:
            logger.error(f"Erreur calcul salary score: {e}")
            return 0.5

    def calculate_freshness_factor(self, job_offer: Dict) -> float:
        """Facteur de fraîcheur de l'offre"""
        try:
            posted_date_str = job_offer.get('date_posted', '')
            if not posted_date_str:
                return 0.5

            # Parser la date
            try:
                posted_date = datetime.strptime(posted_date_str, '%Y-%m-%d')
            except:
                try:
                    posted_date = datetime.strptime(posted_date_str, '%d/%m/%Y')
                except:
                    return 0.5

            days_old = (datetime.now() - posted_date).days

            if days_old <= 7:
                return 1.0
            elif days_old <= 30:
                return max(0.5, 1.0 - (days_old - 7) * 0.02)
            else:
                return 0.3

        except Exception as e:
            logger.error(f"Erreur calcul freshness factor: {e}")
            return 0.5

    def calculate_final_score(self, user_profile: Dict, job_offer: Dict) -> Dict:
        """Calcule le score final de recommandation"""
        try:
            scores = {
                'skills': self.calculate_skills_score(user_profile, job_offer),
                'experience': self.calculate_experience_score(user_profile, job_offer),
                'location': self.calculate_location_score(user_profile, job_offer),
                'salary': self.calculate_salary_score(user_profile, job_offer),
                'freshness': self.calculate_freshness_factor(job_offer)
            }

            # Score pondéré final
            final_score = (
                scores['skills'] * self.weights['skills_match'] +
                scores['experience'] * self.weights['experience_match'] +
                scores['location'] * self.weights['location_match'] +
                scores['salary'] * self.weights['salary_match'] +
                scores['freshness'] * self.weights['freshness_factor']
            )

            return {
                'final_score': round(final_score, 3),
                'detailed_scores': scores,
                'job_id': job_offer.get('id', ''),
                'job_title': job_offer.get('title', ''),
                'company': job_offer.get('company', ''),
                'location': job_offer.get('location', ''),
                'date_posted': job_offer.get('date_posted', '')
            }

        except Exception as e:
            logger.error(f"Erreur calcul final score: {e}")
            return {
                'final_score': 0.0,
                'detailed_scores': {'skills': 0.0, 'experience': 0.0, 'location': 0.0, 'salary': 0.0, 'freshness': 0.0},
                'job_id': job_offer.get('id', ''),
                'job_title': job_offer.get('title', ''),
                'company': job_offer.get('company', ''),
                'location': job_offer.get('location', ''),
                'date_posted': job_offer.get('date_posted', '')
            }

"""# Phase 4 : Génération des Recommandations"""

class RecommendationGenerator:
    def __init__(self):
        self.engine = JobRecommendationEngine()

    def generate_recommendations(self, user_profile: Dict, job_offers: List[Dict], top_n: int = 5) -> List[Dict]:
        """Génère les top N recommandations pour un utilisateur"""
        try:
            if not job_offers:
                return []

            # Initialiser le vectoriseur
            self.engine.initialize_vectorizer([user_profile], job_offers)

            recommendations = []

            for job_offer in job_offers:
                if not job_offer:
                    continue

                score_data = self.engine.calculate_final_score(user_profile, job_offer)
                recommendations.append(score_data)

            # Tri par score décroissant
            recommendations.sort(key=lambda x: x['final_score'], reverse=True)

            # Filtrage des scores trop faibles (seuil plus bas pour mobile)
            filtered_recommendations = [
                rec for rec in recommendations
                if rec['final_score'] >= 0.2  # Seuil plus permissif
            ]

            # Ajouter les explications
            for rec in filtered_recommendations[:top_n]:
                rec['explanations'] = self.explain_recommendation(rec)

            return filtered_recommendations[:top_n]

        except Exception as e:
            logger.error(f"Erreur génération recommandations: {e}")
            return []

    def explain_recommendation(self, recommendation: Dict) -> List[str]:
        """Génère une explication pour une recommandation"""
        try:
            scores = recommendation.get('detailed_scores', {})
            reasons = []

            if scores.get('skills', 0) > 0.7:
                reasons.append("🎯 Excellente correspondance des compétences")
            elif scores.get('skills', 0) > 0.5:
                reasons.append("✓ Bonne correspondance des compétences")
            elif scores.get('skills', 0) > 0.3:
                reasons.append("📚 Opportunité d'apprentissage")

            if scores.get('experience', 0) > 0.8:
                reasons.append("⭐ Expérience parfaitement adaptée")
            elif scores.get('experience', 0) < 0.4:
                reasons.append("🚀 Opportunité de développement")

            if scores.get('location', 0) >= 0.8:
                reasons.append("📍 Localisation idéale")

            if scores.get('salary', 0) > 0.7:
                reasons.append("💰 Salaire attractif")

            if scores.get('freshness', 0) > 0.8:
                reasons.append("🔥 Offre récente")

            return reasons[:3]  # Maximum 3 raisons pour mobile

        except Exception as e:
            logger.error(f"Erreur génération explications: {e}")
            return ["Offre intéressante pour votre profil"]

"""# API"""

class MobileRecommendationAPI:
    """API simplifiée pour application mobile"""

    def __init__(self):
        self.recommender = RecommendationGenerator()

    def get_recommendations_for_user(self, user_profile: Dict, job_offers: List[Dict]) -> Dict:
        """Point d'entrée principal pour l'application mobile"""
        try:
            # Validation des données
            if not user_profile or not job_offers:
                return {
                    'success': False,
                    'error': 'Données manquantes',
                    'recommendations': []
                }

            # Génération des recommandations
            recommendations = self.recommender.generate_recommendations(
                user_profile, job_offers, top_n=5
            )

            # Formatage pour mobile
            formatted_recommendations = []
            for rec in recommendations:
                formatted_rec = {
                    'id': rec.get('job_id', ''),
                    'title': rec.get('job_title', ''),
                    'company': rec.get('company', ''),
                    'location': rec.get('location', ''),
                    'date_posted': rec.get('date_posted', ''),
                    'match_score': f"{rec.get('final_score', 0) * 100:.0f}%",
                    'explanations': rec.get('explanations', []),
                    'detailed_scores': rec.get('detailed_scores', {})
                }
                formatted_recommendations.append(formatted_rec)

            return {
                'success': True,
                'recommendations': formatted_recommendations,
                'total_analyzed': len(job_offers),
                'total_recommended': len(formatted_recommendations)
            }

        except Exception as e:
            logger.error(f"Erreur API mobile: {e}")
            return {
                'success': False,
                'error': str(e),
                'recommendations': []
            }

"""# Exemple"""

import json
import logging

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)


def example_usage():
    """Exemple d'utilisation pour test"""

    # Profil utilisateur exemple
    user_profile = {
        'id': 'user123',
        'skills': ['python', 'javascript', 'react', 'sql'],
        'experience': 3,
        'location': 'tunis',
        'salary_expectation': 50000,
        'accepts_remote': True
    }

    # Offres d'emploi exemple
    job_offers = [
        {
            'id': 'job1',
            'title': 'Développeur Python',
            'company': 'TechCorp',
            'location': 'tunis',
            'date_posted': '2024-01-10',
            'skills_required': ['python', 'django', 'sql'],
            'experience_required': 2,
            'salary': 55000,
            'remote': False,
            'description': 'Développeur Python expérimenté pour projet web'
        },
        {
            'id': 'job2',
            'title': 'Développeur Full Stack',
            'company': 'StartupXYZ',
            'location': 'sfax',
            'date_posted': '2024-01-15',
            'skills_required': ['javascript', 'react', 'node.js'],
            'experience_required': 3,
            'salary': 48000,
            'remote': True,
            'description': 'Développeur full stack pour application mobile'
        }
    ]

    # Utilisation de l'API
    api = MobileRecommendationAPI()
    result = api.get_recommendations_for_user(user_profile, job_offers)

    return result

# Test
if __name__ == "__main__":
    result = example_usage()
    print(json.dumps(result, indent=2, ensure_ascii=False))
